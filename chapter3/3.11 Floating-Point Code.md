# Floating-Point Code
## Floating Point Registers
| 256-bit Register | 128-bit Register | Description         |
| :--------------- | :--------------- | :------------------ |
| `%ymm0`          | `%xmm0`          | 1st FP arg./Return value |
| `%ymm1`          | `%xmm1`          | 2nd FP argument     |
| `%ymm2`          | `%xmm2`          | 3rd FP argument     |
| `%ymm3`          | `%xmm3`          | 4th FP argument     |
| `%ymm4`          | `%xmm4`          | 5th FP argument     |
| `%ymm5`          | `%xmm5`          | 6th FP argument     |
| `%ymm6`          | `%xmm6`          | 7th FP argument     |
| `%ymm7`          | `%xmm7`          | 8th FP argument     |
| `%ymm8`          | `%xmm8`          | Caller saved        |
| `%ymm9`          | `%xmm9`          | Caller saved        |
| `%ymm10`         | `%xmm10`         | Caller saved        |
| `%ymm11`         | `%xmm11`         | Caller saved        |
| `%ymm12`         | `%xmm12`         | Caller saved        |
| `%ymm13`         | `%xmm13`         | Caller saved        |
| `%ymm14`         | `%xmm14`         | Caller saved        |
| `%ymm15`         | `%xmm15`         | Caller saved        |

## Floating Point Instructions
| Instruction | Source | Destination | Description                     |
| :---------- | :----- | :---------- | :------------------------------ |
| `vmovss`    | $M_{32}$ | $X$         | Move single precision           |
| `vmovss`    | $X$    | $M_{32}$    | Move single precision           |
| `vmovsd`    | $M_{64}$ | $X$         | Move double precision           |
| `vmovsd`    | $X$    | $M_{64}$    | Move double precision           |
| `vmovaps`   | $X$    | $X$         | Move aligned, packed single precision |
| `vmovapd`   | $X$    | $X$         | Move aligned, packed double precision |

X: XMM register
(e.g., `%xmm3`); $M_{32}$: 32-bit memory range; $M_{64}$: 64-bit memory range

The instructions with memory reference only operate on individual, rather than packed, data values. These instructions will work correctly regardless of the
alignment of data.

`vmovapd` and `vmovaps` also works when memory reference is needed, however, the address must satisfy a specific alignment requirement.

## Two-operand floating-point conversion operations
| Instruction   | Source     | Destination | Description                                          |
| :------------ | :--------- | :---------- | :--------------------------------------------------- |
| `vcvttss2si`  | $X/M_{32}$ | $R_{32}$    | Convert with truncation single precision to integer  |
| `vcvttsd2si`  | $X/M_{64}$ | $R_{32}$    | Convert with truncation double precision to integer  |
| `vcvttss2siq` | $X/M_{32}$ | $R_{64}$    | Convert with truncation single precision to quad word integer |
| `vcvttsd2siq` | $X/M_{64}$ | $R_{64}$    | Convert with truncation double precision to quad word integer |

When converting floating-point values to integers, they perform truncation,
rounding values toward zero

## Three-operand floating-point conversion operations
| Instruction | Source 1 | Source 2 | Destination | Description |
|---|---|---|---|---|
| `vcvtsi2ss` | M<sub>32</sub>/R<sub>32</sub> | X | X | Convert integer to single precision |
| `vcvtsi2sd` | M<sub>32</sub>/R<sub>32</sub> | X | X | Convert integer to double precision |
| `vcvtsi2ssq` | M<sub>64</sub>/R<sub>64</sub> | X | X | Convert quad word integer to single precision |
| `vcvtsi2sdq` | M<sub>64</sub>/R<sub>64</sub> | X | X | Convert quad word integer to double precision |

The second operand will not affect the lower-bits of the destination.

## Floating Point Format Conversion
### Conversion from single to double precision

Straight forward code:

`vcvtss2sd %xmm0, %xmm0, %xmm0`

Code generated by `GCC`:
```asm
vunpcklps %xmm0, %xmm0, %xmm0 Replicate first vector element
vcvtps2pd %xmm0, %xmm0 Convert two vector elements to double
```

### Conversion from double to single precision

Straight forward code:

`vcvtsd2ss %xmm0, %xmm0, %xmm0`

Code generated by `GCC`:
```asm
vmovddup %xmm0, %xmm0 Replicate first vector element
vcvtpd2psx %xmm0, %xmm0 Convert two vector elements to single
```

## Floating-Point Code in Procedures
The floating point arguments are passed in floating point registers, while the others passed in general propose registers. 

Two types of registers are assigned independently. `%xmm0`-`%xmm7` can be used to pass arguments, and the rest are placed in stack.

The floating point return value is stored in `%xmm0`.

All floating point registers are caller-saved.

## Floating-Point Arithmetic Operations
| Single | Double | Effect | Description |
|---|---|---|---|
| vaddss | vaddsd | $D \leftarrow S_2 + S_1$ | Floating-point add |
| vsubss | vsubsd | $D \leftarrow S_2 - S_1$ | Floating-point subtract |
| vmulss | vmulsd | $D \leftarrow S_2 \times S_1$ | Floating-point multiply |
| vdivss | vdivsd | $D \leftarrow S_2 / S_1$ | Floating-point divide |
| vmaxss | vmaxsd | $D \leftarrow \max(S_2, S_1)$ | Floating-point maximum |
| vminss | vminsd | $D \leftarrow \min(S_2, S_1)$ | Floating-point minimum |
| sqrtss | sqrtsd | $D \leftarrow \sqrt{S_1}$ | Floating-point square root |

Note the sequence of the operands.
## Defining and Using Floating-Point Constants
The floating-point constants must be read from memory.

```
.LC2:
6 .long 3435973837 Low-order 4 bytes of 1.8
7 .long 1073532108 High-order 4 bytes of 1.8
```
On a little-endian machine, the low-order bits are stored in lower memory address.


## Bitwise operations on packed data
| Single | Double | Effect | Description |
|---|---|---|---|
| vxorps | xorpd | $D \leftarrow S_2 \text{ \^{ }} S_1$ | Bitwise EXCLUSIVE-OR |
| vandps | andpd | $D \leftarrow S_2 \& S_1$ | Bitwise AND |

## Floating-Point Comparison Operations
| Instruction | Based on | Description |
|---|---|---|
| ucomiss $S_1, S_2$ | $S_2-S_1$ | Compare single precision |
| ucomisd $S_1, S_2$ | $S_2-S_1$ | Compare double precision |

The floating-point comparison instructions set three condition codes: the zero
flag ZF, the carry flag CF, and the parity flag PF.

For integer operations, PF flag is set when the most recent arithmetic or logical operation yielded a value where the least significant byte has even parity (i.e. ,an even number of ones in the byte). For floating-point comparisons, however, the flag is set when either operand is NaN. If either operand is NaN, the comparison is considered fail.

| Ordering $S_2:S_1$ | CF | ZF | PF |
|---|---|---|---|
| Unordered | 1 | 1 | 1 |
| $S_2 < S_1$ | 1 | 0 | 0 |
| $S_2 = S_1$ | 0 | 1 | 0 |
| $S_2 > S_1$ | 0 | 0 | 0 |


