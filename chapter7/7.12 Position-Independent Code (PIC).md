# Linking 
## 7.12 Position-Independent Code (PIC)
Modern systems compile the code segments of shared libraries so that they can be loaded anywhere in the memory without having to be modified by the linker, so a single copy of shared module's code segment can be shared between multiple processes. That's why shared libraries must always be compiled with `-fpic` flag.

#### PIC Data References
Compilers generate PIC references to global variables by exploiting the following interesting fact: no matter where we load an object module (including shared object modules) in memory, the data segment is always the same distance from the code segment.

That means the distance between the instructions in the code segment and any variable in the data segment is a run-time constant.

So the compiler generates *global offset table* (GOT) at the beginning of the data segment for each global data object. 

At compile time, the compiler can safely code the offset and `%rip` into the code segment to reference the GOT.

At load time, the dynamic linker relocate each GOT entry so that it contains the absolute address of the object. By referencing the GOT, the program get the real location of the variables.

#### PIC Function Calls
At run time, the function call address cannot be modified. So, GNU uses a technique called *lazy binding* to defer the binding of each procedure address until the first time the procedure is called.

This avoids hundreds of unnecessary function relocations at load time.

Lazy binding is implemented with a compact yet somewhat complex interaction between two data structures: the GOT and the *procedure linkage table* (PLT). By invoking dynamic linker at the first time of function call, the linker updates the entry of function location, so the calls afterwards can use the address in the GOT directly.