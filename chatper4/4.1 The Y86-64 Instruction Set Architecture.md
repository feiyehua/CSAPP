# Processor Architecture
The goal of this chapter is to design a instruction set, which is simple version of x86-64, Y86-64.


## 4.1 The Y86-64 Instruction Set Architecture

### 4.1.1 Programmer-Visible State
15 program registers:
%rax, %rcx, %rdx, %rbx, %rsp, %rbp, %rsi, %rdi, and %r8 through %r14. %r15 is omitted.

3 single-bit condition codes, ZF, SF, and OF, storing information about the effect of the most recent arithmetic or logical instruction.

PC, program counter, holds the address of the instruction currently being executed.

Memory, a large array of bytes, can be referenced using virtual address.

A status code `Stat`, indicating the overall
state of program execution.

### 4.1.2 Y86-64 Instructions
The Y86-64 only has 8-byte integer instructions.
+ Split the x86-64 `movq` into 4 different instructions: `irmovq`, `rrmovq`, `mrmovq`, and `rmmovq`. The source is either immediate (i), register (r), or memory (m) (The first character in the instruction). The destination
is either register (r) or memory (m) (The second character in the instruction).

When referencing memory, the second memory address, or the scaling factor is not supported.
+ There are 4 integer operation instructions: `addq`, `subq`, `andq`, and `xorq`, operating only the registers.
+ 7 jump instrucions: jmp, jle, jl, je, jne, jge, and jg
+ 6 conditional move instructions: cmovle, cmovl, cmove, cmovne, cmovge, and cmovg
+ `call` and `ret` instructions
+ `pushq` and `popq` instructions
+ `halt` instructions, which caused the processor to stop, and set `STAT` to `HLT`

### 4.1.3 Instruction Encoding

Each instruction is represented by a sequence of bytes. 

| Instruction | bit 0-3 | bit 4-7 | bit 8-11 | bit 12-15 | Byte 2 | Byte 3 | Byte 4 | Byte 5 | Byte 6 | Byte 7 | Byte 8 | Byte 9 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|
| halt | 0 | 0 | | | | | | | | |
| nop | 1 | 0 | | | | | | | | |
| rrmovq rA, rB | 2 | 0 | rA | rB | | | | | | |
| irmovq V, rB | 3 | 0 | F | rB | | | V (bytes 2-9) | | | |
| rmmovq rA, D(rB) | 4 | 0 | rA | rB | | D (bytes 2-9) | | | | |
| mrmovq D(rB), rA | 5 | 0 | rA | rB | | D (bytes 2-9) | | | | |
| OPq rA, rB | 6 | fn | rA | rB | | | | | | |
| jXX Dest | 7 | fn | | | | Dest (bytes 1-8) | | | | |
| cmovXX rA, rB | 2 | fn | rA | rB | | | | | | |
| call Dest | 8 | 0 | | | | Dest (bytes 1-2) | | | | |
| ret | 9 | 0 | | | | | | | | |
| pushq rA | A | 0 | rA | F | | | | | | |
| popq rA | B | 0 | rA | F | | | | | | |

**Legend:**
* `rA`, `rB`: Register identifiers (typically 4 bits each, combined into one byte).
* `V`: 8-byte immediate value.
* `D`: 8-byte displacement/offset.
* `fn`: Function code (4 bits).
* `Dest`: 8-byte destination address.
* `F`: Represents a fixed value (often 0xF, indicating "no register").
* `OPq`: Arithmetic Instructions
* `jXX`: Jump instructions
* `comvXX`: Conditional move instructions
* Empty cells indicate unused bytes for that instruction, or that the value is part of a multi-byte field (like V, D, Dest).

0-3 bits are `code` part, ranging from `0` to `0xB`. 

4-8 bits are `function` part for `OPq`, `jXX`, and `cmov` instrution family. The detailed function code encodings are given below.

**Operations**

| Instruction | Byte 0-3 | Byte 4-7 |
|---|---|---|
| addq | 6 | 0 |
| subq | 6 | 1 |
| andq | 6 | 2 |
| xorq | 6 | 3 |

**Branches**

| Instruction | Byte 0-3 | Byte 4-7 |
|---|---|---|
| jmp | 7 | 0 |
| jle | 7 | 1 |
| jl | 7 | 2 |
| je | 7 | 3 |
| jne | 7 | 4 |
| jge | 7 | 5 |
| jg | 7 | 6 |

**Moves**

| Instruction | Byte 0-3 | Byte 4-7 |
|---|---|---|
| rrmovq | 2 | 0 |
| cmovle | 2 | 1 | 
| cmovl | 2 | 2 |
| cmove | 2 | 3 |
| cmovne | 2 | 4 |
| cmovge | 2 | 5 |
| cmovg | 2 | 6 |

Note the special encoding for rrmovq, as it can be seen as an “unconditional move”, having the same `function` code 0.


The encoding for registers are given below:

| Number | Register name | Number | Register name |
|---|---|---|---|
| 0 | %rax | 8 | %r8 |
| 1 | %rcx | 9 | %r9 |
| 2 | %rdx | A | %r10 |
| 3 | %rbx | B | %r11 |
| 4 | %rsp | C | %r12 |
| 5 | %rbp | D | %r13 |
| 6 | %rsi | E | %r14 |
| 7 | %rdi | F | No register |

Encoding `F` is used to indicate that no register should be accessed.

Some instructions require an 8-Byte constant value. This value can be an immediate constant, the displacement for rmmovq and mrmovqaddress specifiers, or an address.
Branch and call destinations are given as absolute addresses, rather than using the PC-relative addressing seen in x86-64.

